//#include <sys/stat.h>
//#include "Breed.h"
#include <iostream>
//#include "ResidueStretchContainer.h"
#include "PrimaryJobData.h"
#include "BreederParameterReader.h"
#include "sys/types.h"
#include "sys/sysinfo.h"


void printUsage() {
   std::cout<<std::endl;
   std::cout << "Usage: ./homologyScanner [options] " << std::endl;
   std::cout << "Options: " << std::endl;

    std::cout << " -PDBID                    <4-character ID string> This tells homologyScanner which structure you will be working with. It is used also for setting the primary jobName, which in turn also sets the primary directory name. homologs will be named differently not under direct control of this parameter. " << std::endl;

//and mutationString as main input:

    std::cout << " -ONEMUTANT                    <mutation string> This tells breeder to compute one mutant. For the mutation string, follow the format: C-NNNI-S.c-nnni-s, where e.g. C,c are chain ID's, NNN and nnn are residue numbers, I and i are insertion codes (if any), and S and s are the mutant residue type in single letter code.  These can be concatenated with '.', up to the limitation of maxMutants. " << std::endl;
   std::cout << " -CHAINSINCOMPLEX               <chain IDs>  FoldX requires the chain IDs of ONE of the two interacting complexes, followed by a comma, followed by the chain IDs of the other interacting complex. For instance if chains A and B are in one complex, which interacts with a second complex comprising chains C and D, then specify AB,CD . " << std::endl;
   std::cout << " -WORKINGDIRECTORY             <path>  This sets the batch_directory column in the jobInfo table for the given runID.  In this directory, subdirectories will appear named after each mutation, and each of these subdirectories will contain the files generated by breeder, foldx, etc., for that mutation. " << std::endl;
}

int main(int num_args, char *args[]){
    struct sysinfo memInfo;
    sysinfo (&memInfo);
    long long totalVirtualMem;
    totalVirtualMem  = memInfo.totalram;
    //Add other values in next statement to avoid int overflow on right hand side...
    totalVirtualMem += memInfo.totalswap;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Total swap memory used : "<<memInfo.totalswap <<" bytes "<<std::endl;
    totalVirtualMem *= memInfo.mem_unit;
    long long physMemUsed = memInfo.totalram - memInfo.freeram;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Total RAM  : "<<memInfo.totalram  <<" bytes "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Free  RAM  : "<<memInfo.freeram  <<" bytes "<<std::endl;
    //Multiply in next statement to avoid int overflow on right hand side...
    physMemUsed *= memInfo.mem_unit;    
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<physMemUsed<<" bytes "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<1.0*physMemUsed/(1024*1024*1024)<< " GB "<<std::endl;


    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    sysinfo (&memInfo);
    totalVirtualMem = memInfo.totalram;
    //Add other values in next statement to avoid int overflow on right hand side...
    totalVirtualMem += memInfo.totalswap;
    totalVirtualMem *= memInfo.mem_unit;
    physMemUsed = memInfo.totalram - memInfo.freeram;
    //Multiply in next statement to avoid int overflow on right hand side...
    physMemUsed *= memInfo.mem_unit;    
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<physMemUsed<<" bytes "<<std::endl;
    ParameterReader myParameterReader;
    //std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<1.0*physMemUsed/(1024*1024*1024)<< " GB "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" homologyScanner completed." <<std::endl;
    return 0;
}
