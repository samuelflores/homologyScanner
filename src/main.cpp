//#include <sys/stat.h>
//#include "Breed.h"
#include <iostream>
//#include "ResidueStretchContainer.h"
#include "PrimaryJobData.h"
#include "BreederParameterReader.h"
#include "sys/types.h"
#include "sys/sysinfo.h"


void printUsage() {
   std::cout<<std::endl;
   std::cout << "Usage: ./homologyScanner [options] " << std::endl;
   std::cout << "Options: " << std::endl;

    std::cout << " -PDBID                    <4-character ID string> This tells homologyScanner which structure you will be working with. It is used also for setting the primary jobName, which in turn also sets the primary directory name. homologs will be named differently not under direct control of this parameter. " << std::endl;

//and mutationString as main input:

    std::cout << " -ONEMUTANT                    <mutation string> This tells breeder to compute one mutant. For the mutation string, follow the format: C-NNNI-S.c-nnni-s, where e.g. C,c are chain ID's, NNN and nnn are residue numbers, I and i are insertion codes (if any), and S and s are the mutant residue type in single letter code.  These can be concatenated with '.', up to the limitation of maxMutants. " << std::endl;
   std::cout << " -CHAINSINCOMPLEX               <chain IDs>  FoldX requires the chain IDs of ONE of the two interacting complexes, followed by a comma, followed by the chain IDs of the other interacting complex. For instance if chains A and B are in one complex, which interacts with a second complex comprising chains C and D, then specify AB,CD . " << std::endl;
   std::cout << " -WORKINGDIRECTORY             <path>  This sets the batch_directory column in the jobInfo table for the given runID.  In this directory, subdirectories will appear named after each mutation, and each of these subdirectories will contain the files generated by breeder, foldx, etc., for that mutation. " << std::endl;
}

int main(int num_args, char *args[]){
    struct sysinfo memInfo;
    sysinfo (&memInfo);
    long long totalVirtualMem;
    totalVirtualMem  = memInfo.totalram;
    //Add other values in next statement to avoid int overflow on right hand side...
    totalVirtualMem += memInfo.totalswap;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Total swap memory used : "<<memInfo.totalswap <<" bytes "<<std::endl;
    totalVirtualMem *= memInfo.mem_unit;
    long long physMemUsed = memInfo.totalram - memInfo.freeram;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Total RAM  : "<<memInfo.totalram  <<" bytes "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Free  RAM  : "<<memInfo.freeram  <<" bytes "<<std::endl;
    //Multiply in next statement to avoid int overflow on right hand side...
    physMemUsed *= memInfo.mem_unit;    
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<physMemUsed<<" bytes "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<1.0*physMemUsed/(1024*1024*1024)<< " GB "<<std::endl;


    PrimaryJob myPrimaryJob;
    // Set some default values:
    //BreederParameterReader myBreederParameterReader;    
    myPrimaryJob.breederParameterReader.printUsage();
    myPrimaryJob.breederParameterReader.jobId = "";
    myPrimaryJob.breederParameterReader.pdbId = "";
    myPrimaryJob.breederParameterReader.chainsInMutatedSubunit = "";
    myPrimaryJob.breederParameterReader.oneMutationString      = "";
    // myPrimaryJob.breederParameterReader.workingDirectory       = "/home/samuelf/glob/projects/SKEMPI-homologyScanner/";
    //myPrimaryJob.breederParameterReader.jobLibraryPath         = "/sw/comp/gcc/5.1.0_tintin/lib64:/sw/comp/gcc/5.1.0_tintin/lib:/home/samuelf/SimTK/lib64";
    // Done setting defaults

    // Now read the parameters from the command line
    myPrimaryJob.breederParameterReader.setDefaults ();
    myPrimaryJob.breederParameterReader.readParameters(   num_args, args);
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<"myPrimaryJob.breederParameterReader.jobId = >"<< myPrimaryJob.breederParameterReader.jobId <<"< ."<<std::endl;
    myPrimaryJob.breederParameterReader.validate();
    myPrimaryJob.breederParameterReader.validateForHomologyScanner();
    if (myPrimaryJob.breederParameterReader.workingDirectory == "") {std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" The -WORKINGDIRECTORY parameter is required. "<<std::endl; exit(1);}
    else {std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" The -WORKINGDIRECTORY parameter is apparently set to >"<<myPrimaryJob.breederParameterReader.workingDirectory<<"< "<<std::endl;}
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" "<<std::endl;
    std::string myChainsInMutatedSubunit = "";
    //std::string myWorkingDirectory = "/home/samuelf/glob/projects/SKEMPI-homologyScanner/";
    myPrimaryJob.setMutationString(myPrimaryJob.breederParameterReader.oneMutationString);
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" myPrimaryJob.breederParameterReader.workingDirectory = >"<<myPrimaryJob.breederParameterReader.workingDirectory<<"<"<<std::endl;
    //myPrimaryJob.setPdbId(myPrimaryJob.breederParameterReader.pdbId ); 
    myPrimaryJob.initializeDbConnection(myPrimaryJob.breederParameterReader, myPrimaryJob.breederParameterReader.jobId  );
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" Have now set PDB ID to : "<<myPrimaryJob.getPdbId()<<std::endl;  
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" About to set myPrimaryJob.overarchingDirectory = >"<< myPrimaryJob.breederParameterReader.workingDirectory<<"< " <<std::endl;  
    myPrimaryJob.overarchingDirectory =  myPrimaryJob.breederParameterReader.workingDirectory ;
    myPrimaryJob.setWorkingDirectory(); // This can be set now, since we have overarchingDirectory  taken care of
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" myPrimaryJob.getWorkingDirectory() = >"<<myPrimaryJob.getWorkingDirectory()<<"< "<<std::endl;
    //myPrimaryJob.jobLibraryPath = myPrimaryJob.breederParameterReader.jobLibraryPath; 

    myPrimaryJob.setMutationString(myPrimaryJob.breederParameterReader.oneMutationString );
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" myPrimaryJob.getWorkingDirectory() = >"<<myPrimaryJob.getWorkingDirectory()<<"< "<<std::endl;
    //myPrimaryJob.setPdbId(myPrimaryJob.breederParameterReader.jobId); // This is a patch ! add a PDB ID parameter! // Overrides the above default.
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    // This is just a function to parse the chainsInMutatedSubunit string and load it into the more-structured chainAndComplexNumberMap :
    myPrimaryJob.loadChainAndComplexNumberMap (myPrimaryJob.breederParameterReader.chainsInMutatedSubunit);
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" myPrimaryJob.getWorkingDirectory() = >"<<myPrimaryJob.getWorkingDirectory()<<"< "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    //myPrimaryJob.jobLibraryPath =  myPrimaryJob.breederParameterReader.jobLibraryPath;
    //myPrimaryJob.workingDirectory = (myWorkingDirectory); 
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" Checking..   PDB ID is set to : >"<<myPrimaryJob.getPdbId()<<"< "<<std::endl;  
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" myPrimaryJob.getWorkingDirectory() = >"<<myPrimaryJob.getWorkingDirectory()<<"< "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" myPrimaryJob.getWorkingDirectory() = >"<<myPrimaryJob.getWorkingDirectory()<<"< "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    myPrimaryJob.fetchPdb();  
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" myPrimaryJob.getWorkingDirectory() = >"<<myPrimaryJob.getWorkingDirectory()<<"< "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    //// Now populate the sequence table
    myPrimaryJob.initializeSequencesFromPdb();   
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    // SCF trying to exclusively use the one  in PrimaryJobData.cpp:
    if (myPrimaryJob.breederParameterReader.sequence ) { // if user specified -SEQUENCE, getSequenceOnly() returns 1. That means the user only wants to populate the sequence table, nothing else. So do this bit and then quit.
    //if ((*(myPrimaryJob.dbConnection)).getSequenceOnly()) { // if user specified -SEQUENCE, getSequenceOnly() returns 1. That means the user only wants to populate the sequence table, nothing else. So do this bit and then quit.
        std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
        Chromosome myChromosome(  0                               , myPrimaryJob.getBiopolymerClassContainer() );
        std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" About to call populateSequenceTable"<<std::endl;
        myChromosome.populateSequenceTable(*(myPrimaryJob.dbConnection));
        std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" Done with populateSequenceTable. Will now exit without error"<<std::endl;
        //// Sequence table should be populated now with both PDB and renumbered residue numbers
        exit  ( 0);
    }
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" myPrimaryJob.getWorkingDirectory() = >"<<myPrimaryJob.getWorkingDirectory()<<"< "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    std::ofstream fullOutputStreamP0(std::string(myPrimaryJob.getPdbNumberedStructureFileName() + ".parent.0.pdb").c_str());
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" myPrimaryJob.getWorkingDirectory() = >"<<myPrimaryJob.getWorkingDirectory()<<"< "<<std::endl;
    myPrimaryJob.updBiopolymerClassContainer().writeDefaultPdb(  fullOutputStreamP0); 
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    myPrimaryJob.setMutationVectorFromMutationString(); // uses myPrimaryJob.getMutationString(), calls biopolymerClassContainer.setMutationVectorFromString( getMutationString()) . This has to be done after initializeSequencesFromPdb because otherwise there will be no BiopolymerClass's to validate the mutations against.

    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    sysinfo (&memInfo);
    totalVirtualMem = memInfo.totalram;
    //Add other values in next statement to avoid int overflow on right hand side...
    totalVirtualMem += memInfo.totalswap;
    totalVirtualMem *= memInfo.mem_unit;
    physMemUsed = memInfo.totalram - memInfo.freeram;
    //Multiply in next statement to avoid int overflow on right hand side...
    physMemUsed *= memInfo.mem_unit;    
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<physMemUsed<<" bytes "<<std::endl;
    //ParameterReader myParameterReader;
    //std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<1.0*physMemUsed/(1024*1024*1024)<< " GB "<<std::endl;
    if (myPrimaryJob.breederParameterReader.singleHomologyScannerRun){ // Single run. This is a "leaf" run which does only one job and dies. Is called potentially many times for a single overarching job.
        myPrimaryJob.createSingleHomologJobAndAddToVector(myPrimaryJob.breederParameterReader.homologPdbId, myPrimaryJob.breederParameterReader.chainsInHomologComplex);
    } else { // overarching run. loads homologJobVector with potentially many homologJobs.
        myPrimaryJob.loadHomologJobVector();
    }
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    sysinfo (&memInfo);
    totalVirtualMem = memInfo.totalram;
    //Add other values in next statement to avoid int overflow on right hand side...
    totalVirtualMem += memInfo.totalswap;
    totalVirtualMem *= memInfo.mem_unit;
    physMemUsed = memInfo.totalram - memInfo.freeram;
    //Multiply in next statement to avoid int overflow on right hand side...
    physMemUsed *= memInfo.mem_unit;    
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<physMemUsed<<" bytes "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<1.0*physMemUsed/(1024*1024*1024)<< " GB "<<std::endl;

    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<std::endl;
    if (myPrimaryJob.breederParameterReader.singleHomologyScannerRun){ // Single run. This is a "leaf" run which does only one job and dies. Is called potentially many times for a single overarching job.
        myPrimaryJob.printCorrespondenceTable(); // This calls breeder on all homologJobs in homologJobVector -- which is exactly one job.
    } else { // overarching run
        myPrimaryJob.spawnSingleHomologyScannerRunsFromHomologJobVector(); // Runs through all the (potentially many)  homologJobs in homologJobVector -- and spawns one homologyScanner leaf job for each. Each will end up in the condition above. 
    }
    myPrimaryJob.dbConnection->close(); // We create many leaf jobs, so we have to make sure to close this.
    sysinfo (&memInfo);
    totalVirtualMem = memInfo.totalram;
    //Add other values in next statement to avoid int overflow on right hand side...
    totalVirtualMem += memInfo.totalswap;
    totalVirtualMem *= memInfo.mem_unit;
    physMemUsed = memInfo.totalram - memInfo.freeram;
    //Multiply in next statement to avoid int overflow on right hand side...
    physMemUsed *= memInfo.mem_unit;    
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<physMemUsed<<" bytes "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<< " Physical memory used : "<<1.0*physMemUsed/(1024*1024*1024)<< " GB "<<std::endl;
    std::cout<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<" homologyScanner completed." <<std::endl;
    return 0;
}
